# PRIP 相关 linux 内核协议栈分析和调测技术

[toc]



## 1.功能需求技术方案

在 linux 操作系统中,网络数据是由内核网络协议栈进行处理的,这一处理过程如图所示。

![](图片/prip相关linux内核协议栈分析和调测技术/1.png) 



当收到数据包时,会触发网卡中断,由中断服务程序完成数据接收。网卡驱动程序去掉数据包的数据链路层协议头后,接收软中断会调用协议栈三层的接口函数将数据包交给协议栈三层处理。在协议栈三层里,首先对输入包进行路由,若数据包不是发给本机的且本机设置了转发功能,那么会对数据包进行输出路由,选择合适的网络接口和下一跳目的地址发送出去。

在协议栈三层,在数据包经过路由子系统、IP 协议头正确性检查、IP 分片组装之后(如果有的话),会进入 PRIP 协议接收处理模块。在 PRIP 协议接收处理模块中,首先检查数据包是否属于 PRIP 连接的包,若不是,则不做处理,将数据包继续向上层推送。 若数据包属于 PRIP 连接的包,则通过解些 Ip-options 提取 PRIP 序列号和主从标志,通过查询 PRIP 序列号缓存表来判断该序列号的包是否已经收到。 若未收到,则是第一次到达的包,接收并向协议栈上层推送。 若已经受到,则属于冗余包,丢弃处理。

当应用程序发送网络数据时候,如果是进行 PRIP 通信,应用程序会调用相应的应用程序接口设置数据包的 PRIP 标志。数据包经协议栈四层处理之后,会被交给协议栈三层。在协议栈三层,数据包在添加了三层协议头之后,会被交给 PRIP 发送模块处理。在 PRIP 发送模块里,若数据包是正常的网络数据包,则不做处理,向下发送。若数据包属于 PRIP 包,会将当前的数据包复制一份,并将复制出来的包的目的地址替换为 PRIP 从链路的远端 IP 地址。同时,用当前的 PRIP 流水序列号为两个包构建 Ip
options。之后,将两个包交给路由子系统。

路由子系统会为数据包选择合适的发送网络接口和下一跳地址。同时会查看路由查询结果里是否已经为本数据包缓存了数据链路层硬件头缓存,如果有,则调用邻居子系统的发送接口执行快速发送。若没有缓存数据链路层协议头,则调用邻居子系统的发送接口进行慢速发送,此时,邻居子系统会先进行 arp请求,来获得目的地址的 MAC 地址,然后调用相应的网卡驱动发送数据。



## 2. PRIP 冗余发送功能实现

为确保数据业务的高可靠行,PRIP 协议要求对同一份数据须生成两份,经两个相互独立的物理链路进行传输,即实现数据传输冗余。

PRIP 采用修改协议栈处理流程的办法,在数据包的发送路径的合适的点来进行 PRIP 的发送处理。因为这个点并不位于协议栈的 Net filter 钩子点,采用独立的模块的办法不能实现,所以需要在协议栈内部直接嵌入我们的代码。

方案如下:
该方案的实现模块被称为 PRIP 发送处理模块。该模块处于协议栈三层,即 IP 网络层内。对于 IPV4 来
说,IP 网络层在数据包发送方面所作的工作主要有:
1.构建并填充 IP 协议头。
2.构建 IP 选项(如果有)。
3.Ip 数据包的分片(如果需要)。
4.Ip 发送路由选路。
5.由网络过滤子系统检查数据包。
6.更新相关统计信息。
7.调用数据链路层入口函数将数据包向下层发送。
在 linux 内核中,TCP 协议和 UDP 协议数据包的发送路径不尽相同,下面将计针对两种协议不同的设计方案予以介绍。在介绍之前,再简单呈现 TCP 协议的三次握手和断开连接四次握手过程。



![](图片/prip相关linux内核协议栈分析和调测技术/2.png) 



在 TCP/IP 协议中,TCP 协议提供可靠的连接服务,采用三次握手建立一个连接。

第一次握手:建立连接时,客户端发送 syn 包(syn=j)到服务器,并进入 SYN_SEND 状态,等待服务器确认;

第二次握手:服务器收到 syn 包,必须确认客户的 SYN(ack=j+1),同时自己也发送一个 SYN 包(syn=k),即 SYN+ACK 包,此时服务器 进入 SYN_RECV 状态;

第三次握手:客户端收到服务器的 SYN+ACK 包,向服务器发送确认包 ACK(ack=k+1),此包发送完毕,客户端和服务器进入 ESTABLISHED 状态,完成三次握手。 完成三次握手,客户端与服务器开始传送数据。

由于 TCP 连接是全双工的,因此每个方向都必须单独进行关闭。这个原则是当一方完成它 的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动,一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭,而另一方执行被动关闭:
(1)客户端 A 发送一个 FIN,用来关闭客户 A 到服务器 B 的数据传送。
(2)服务器 B 收到这个 FIN,它发回一个 ACK,确认序号为收到的序号加 1。和 SYN 一样,一个 FIN将占用一个序号。
(3)服务器 B 关闭与客户端 A 的连接,发送一个 FIN 给客户端 A。
(4)客户端 A 发回 ACK 报文确认,并将确认序号设置为收到序号加 1。

Linux 内核协议栈在发送数据上不同的协议或不同类型的数据包处理放式不尽相同。在 TCP 协议和 UDP 协议数据的发送方面存在四条不同的发送路径。如下图所示:

![](图片/prip相关linux内核协议栈分析和调测技术/3.png) 



对于 TCP 协议数据来说,共有三条不同的发送路径:
(1)对于正常的数据包、 TCP 三次握手 SYN 包、 TCP 三次握手 ACK 包、 TCP 断开连接四次挥手FIN 包来说,其发送路径如上图中红色箭头所示。在该路径上,调用 ip_queue_xmit()函数,在该函数内部,如果数据包尚未进行路由,则对对数据包进行路由,然后调用 ip_local_out()函数进入所有包 IP 网络层统一发送路径。

(2)对于 TCP 协议三次握手中的 SYN+ACK 包来说,其发送路径如上图中中黑色箭头所示。 在该路径上,调用__tcp_v4_send_synack()函数对数据包进行路由,成功之后调用 ip_local_out()函数进入所有包 IP 网络层统一发送路径。

(3)对于 TCP 复位连接 RST 数据包和四次分手 LAST_ACK 数据包来说,起发送路径如上图中的蓝色箭头所示。在该路径上,会调用 ip_send_unicast_reply()函数对 RST 或者 LAST_ACK 数据包进行路由,成功之后调用 ip_push_pending_frames()函数,然后调用 ip_local_out()函数进入所有包 IP 网络层统一发送路径。

对于 UDP 协议数据包来说,只存在一条发送路径,如上图中的绿色箭头所示。在 UDP 发送路径上 ,会 调 用 udp_senmsg() 函 数 对 尚 未 进 行 路 由 的 数 据 包 进 行 路 由 , 路 由 成 功 之后 调 用 ip_push_pending_frames()函数,之后调用 ip_local_out()函数进入所有包 IP 网络层统一发送路径。

其中, 上图中棕色框中为根据 PRIP 并行冗余互联协议设计需要 进行修改的函数。包括ip_send_reply() 函 数 、 ip_queue_xmit() 函 数 、 tcp_v4_send_synack() 函 数 、udp_sendmsg() 函 数 和 ip_push_pending_frame()函数。



### 2.1 TCP 协议 PRIP 协议冗余发送处理

据 PRIP 并行冗余互联协议功能需求,对于 TCP 协议来说,PRIP 数据冗余发送主要完成以下几方面工作:
(1)生成冗余包,即生成从包,包括复制主包数据及从包目的 IP 替换。
(2)为主从包构建相应的 PRIP 协议 IP 选项。
(3)为从包进行路由。
(4)发送主从包。
在修该内核代码的时候,本设计方案将遵循一下两个原则:
(1)就近修改原则。例如,本设计将在标准内核源码进行 IP 选项解析的地方增加 PRIP 协议 IP 选项的解析;在标准内核源码对 Ip 选项进行构建的地方,本设计增加 PRIP 协议 IP 选项的构建。

(2)主从包处理镜像对称原则。在从包生成以后,将保证从包具备与主包具有对等的相应特性,并在以后的处理中,使得主从包处理呈对称特性。例如,在对主包进行数据统计地方,也必须对从包进行统计;在标准内核源代码内为数据包进行路由的地方,需增加对从包的路由;若生成从包时主包已经进行过 IP路由,则必须对生成从包单独进行路由(替换目的 IP 之后)。

遵循这两项原则,可以最大限度保留内核协议栈原有优良层次结构,并且可以简化设计,快速筛选和锁定所要修改的源码位置。



#### 2.1.1 正常已建立连接 TCP 数据包的 PRIP 冗余发送处理

正常内核协议栈中已建立连接的 TCP 数据发送路径如上图中的红线箭头所示,该发送路径同时也是TCP 三次握手 SYN 包、 TCP 三次握手 ACK 包、 TCP 断开连接四次挥手 FIN 包的发送路径。为了实现 PRIP 协议数据冗余发送功能,本设计选择在函数 ip_queue_xmit()函数里面实现该功能。主要基于以下几种考虑:

(1)ip_queue_xmit()函数函数实现包含了 IP 选项的创建(调用 ip_build_options()函数)。根据“就近修改”的原则,PRIP 协议 IP 选项的构建需要放在 ip_build_options()函数里面实现。ip_queue_xmit()函数包含 IP 选项的创建,就必须为从包创建 IP 选项,从包的 IP 选项的创建也最好放在这里。

(2)ip_queue_xmit()函数会判断数据包是否已经经过路由,如果没有的话需要为数据包进行路由。所以对从包进行路由也需要放在这里。确保主从包处理的对称顾。

基于上述原因 , 本设计选在 ip_queue_xmit() 函数里实现 PRIP 协议冗余发送功能 。由于ip_queue_xmit()函数位于协议三层的顶部,所以该发送路径实现完全位于协议三层,即 IP 网络层。标准 Linux4.9.130 内核 ip_queue_xmit()函数位于 L3 层的最上部,它由传输层 L2 层在发送数据时调用。 该函数首先检查数据包是否已经缓存了路由信息,如果没有,就查询路由缓存。 若路由查找失败,则说明还没有为该数据包创建路由缓存,那么就接着查询路由表,并根据查询结果创建属于该数据包的路由缓存;其次,为数据包构建并初始化 IP 协议头,并查看该数据包是否设置了 IP 选项,如果有,则为该数据包构建相应的 IP 选项。最后调用 ip_local_output()函数向下发送 IP 数据包。

ip_queue_xmit_prip() 函 数 为 PRIP 协 议 冗 余 数 据 发 送 的 真 正 实 现 函 数 。 其实 现 位 于 Linux4.9.130/net/ipv4/ip_out.c 文件里,函数代码如下:

```
int ip_queue_xmit_prip(struct sock *sk, struct sk_buff *skb, struct flowi *fl)
{

}
```

综上分析,正常数据包 PRIP 协议数据冗余发送模块工作可概括为:
(1)查看主包路由缓存是否存在;若不存在重新进行路由;如果路由失败,记录主包发送失败,进入发送从包环节;如果发送成功,但路由下一跳地址不等于主包目的 IP 地址,那么记录主包发送失败,进入发送从包环节。
(2)如果主包路由成功且路由下一跳地址等于目的 IP 地址。初始化主包 IP 协议头。
(3)为主包构建 PRIP 协议 IP 选项。
(4)复制主包生成从包。
(5)发送主包,并记录主包发送成功与否。
(6)对从包进行路由查询。若查询失败,记录从包路由失败;若查找成功则查看下一跳地址是否等于从包目的地址。若不等于,记录从包路由失败。
(7)替换从包目的 IP 地址。
(8)替换从包 PRIP 选项主标志为从标志。从包复制于主包,并且和 IP 选项一块复制,所以需要替换。
(9)发送从包。如果主包和从包均发送失败,那么返回发送失败;否则,返回发送成功。



#### 2.1.2 TCP 协议 SYN+ACK 包 PRIP 协议冗余发送处理

正常协议栈 TCP 协议 SYN+ACK 数据包的发送路径为黑色箭头所示。其发送路径上会调用__tcp_v4_send_synack()函数,该函数用来为服务器构造回应客户端连接请求 SYN 段的 SYN+ACK 段,并将 SYN+ACK 段封装在 IP 报文中发送给客户端。__tcp_v4_send_synack()函数调用ip_local_out()函数进入所有包 IP 网络层统一发送路径。

本设计最终选择在__tcp_v4_send_synack()函数里面实现 SYN+ACK 包 PRIP 协议冗余发送处理。主要基于以下考虑:__


(1) __tcp_v4_send_synack()函数调用 inet_csk_route_req()函数对输出数据包进行路由,这是SYN+ACK 数据包发送路径上的唯一一次路由查询。故 PRIP 协议从包的路由查询最好放在此处。__


(2) __tcp_v4_send_synack()通过调用 ip_build_and_send_pkt()函数来为数据包创建 IP 选项。根据“就近修改”原则,最好将 PRIP 主从数据包的 IP 选项构建放在这里。__

可见在 SYN+ACK 数据包的发送路径上,__tcp_v4_send_synack()函数里既有为数据包路由的动作,也有为数据包创建 IP 选项的动作,若将 PRIP 协议的 SYN+ACK 数据包冗余发送放在该函数里面实现可以最大限度的保留内核的原有层次结构,也更顺理成章。
__tcp_v4_send_synack()函数位于传输层,故 TCP 协议 SYN+ACK 包 PRIP 协议冗余发送处理也在传输层里实现。对于携带 PRIP 协议 IP 选项标志的 SYN+ACK 数据包会调用_tcp_v4_send_synack_prip()函数,对于正常 SYN+ACK 数据包仍然走正常协议处理流程。

__tcp_v4_send_synack_prip()位 于 内 核 Linux4.9.130/net/ipv4/tcp_v4.c 文件里面,代码如下:

```
static int tcp_v4_send_synack_prip(const struct sock *sk, struct dst_entry *dst,
struct flowi *fl,
struct request_sock *req,
struct tcp_fastopen_cookie *foc,
enum tcp_synack_type synack_type)
{
..................

}
```



可见 SYN+ACK 包 PRIP 协议冗余发送处理的流程与 2.1.1 节的正常 TCP 数据包的 PRIP 冗余发送处理流程极为相似:
(1)如果主包路由缓存不存在,则为主包进行路由,并记录主包路由成功与否。主包路由失败就意味着主包不能发送。
(2)获取从包目的 IP 地址。并为从包进行路由。路由成功后,判断路由下一跳是否等于从包目的 IP地址,不等则说明路由不合法,释放从包路由缓存结构。
(3)为主包构造 SYN+ACK 段。并初始化 TCP 首部及 SKB 中各字段项,并填入相应的 TCP 选项(如果有)。
(4)初始化主包 IP 协议头,构建主包 PRIP 协议 IP 选项。
(5)复制主包,生成从包。
(6)发送主包,并记录主包发送结果。
(7)如果主包路由失败,则为从包构造 TCPSYN+ACK 段、 TCP 协议头及添加 TCP 选项。 初始化IP 协议头,包括从包目的 IP 地址替换,构建从包 PRIP 协议 IP 选项。
(8)如果主包路由成功。只需对从包进行目的 IP 地址替换,并将从包 IP 选项里的主标志替换为从标志。因为从包复制于主包,会将 IP 协议头和 IP 选项一并复制,只需简单替换即可。
(9)发送从包并记录从包发送状态。
(10)如果主包和从包均发送失败,返回发送失败;否则,返回发送成功。



#### 2.1.3 TCP 协议 RST 数据包 PRIP 协议冗余发送处理

在 TCP 协议中 RST 表示复位,用来异常的关闭连接,在 TCP 的设计中它是不可或缺的。发送 RST包关闭连接时,不必等缓冲区的包都发出去,直接就丢弃缓存区的包发送 RST 包。而接收端收到 RST 包后,也不必发送 ACK 包来确认。

可见,RST 数据包虽然属于 TCP 协议范畴,但其的发送和接收跟 UDP 的特性极为相似,因而,Linux内核协议栈对 RST 的发送在 IP 层上的处理走的是 UDP 的发送路径。在该发送路径上会先调用ip_send_unicast_reply()函数,然后调用 ip_push_pending_frames()函数,ip_push_pending_frames()函数调用 ip_local_out()函数进入所有包 IP 网络层统一发送路径。

本设计将对 RST 数据包发送路径上的 ip_send_unicast_reply()函数和ip_push_pending_frames()函数进行修该以实现 PRIP 冗余发送的功能。主要基于以下考虑:
(1)ip_send_unicast_reply()函数会对要发送的 RST 数据包进行路由。并且,当数据路由失败的时候将放弃 RST 数据包的发送。假设这种情况:在 PRIP 协议冗余通信的时候,如果主网卡因为某种原因比如说 DOWN 掉的时候,会表现为路由不可达,但从网卡是正常工作的。 这是如果发起数据发送将是不可容忍的。所以,需要修改 ip_send_unicast_reply()函数:在主包路由失败的情况下,需要对从包再进行路由,如果从包路由成功,继续进行发送工作。

(2)ip_push_pending_frames()函数中涉及到 ip 数据包的 IP 选项的创建,因而,根据“就近修改原则”,将主从包的 PRIP 选项的创建放在这里比较合适。最终,将在本函数里,实现从包的生成、PRIP 协议 IP 选项的构建和主从包的发送。ip_send_unicast_reply()函数和 ip_push_pending_frames()函数位于 IP 网络层的顶部,因而
TCP 协议 RST 数据包 PRIP 协议冗余发送处理是在 IP 网络层实现的。

ip_send_unicast_reply()函数位于内核源码 Linux4.9.130/net/ipv4/ip_output.c 文件里。修改后函数代码如下:

```
void ip_send_unicast_reply(struct sock *sk, struct sk_buff *skb,
const struct ip_options *sopt,
__be32 daddr, __be32 saddr,
const struct ip_reply_arg *arg,
unsigned int len)
{
................

}
```

本函数会在主包路由失败的情况下,继续对从包进行路由。如果主包路由成功,则不进行从包路由,而后发送数据包。
需要说明的时,此时从包尚未产生。对从包路由指的是,是以从包目的 IP 进行路由。
ip_push_pending_frames()函数位于内核源码 Linux4.9.130/net/ipv4/ip_output.c 文件里。修改后函数代码如下:

```
int ip_push_pending_frames_prip(struct sock *sk, struct flowi4 *fl4)
{

}
```



可见,在 ip_send_unicast_reply()函数里面,如果主链路不可达,就会继续以从包目的 IP 进行路
由尝试,这样做在主链路故障,而从链路正常的情况下,继续发送数据。并记录是为主包还是从包进行过
路由。
ip_push_pending_frames()函数与 ip_queue_xmit_prip 实现的功能类似,也是查找路由后发送主
从包,但也有一些区别。即:该函数在被调用时已经获得了主路由或从路由(在 udp_sendmsg 或
ip_send_unicast_reply 中查找获得)其中之一,所以路由查找只会进行一次。在该函数中,需要判断该
路由是主路由还是从路由,确定方法就是在调用它的 udp_sendmsg 或 ip_send_unicast_reply 中根据
获得的路由的主从性对与传入该函数的 sock 相关的 opt(可由 sock 获得)中的__data 中的选项内容
中的主从标志位进行设置,如为主路由则为 0,从路由为 1。随后,在该函数中,会对将要传输的数据包的
源地址,目的地址进行相应的变换。其余功能则与 ip_queue_xmit_prip 类似。



### 2.2 UDP 协议 PRIP 协议冗余发送处理

正常内核协议栈中 UDP 数据发送会 先 调 用 udp_sendms() 函 数 , 然 后 调 用
ip_push_pending_frames() 函 数 ,ip_push_pending_frames()函数调用 ip_local_unicast_out()函
数进入所有包 IP 网络层统一发送路径。
本设计将对 UDP 协议数据包发送路径上的 udp_sendmsg()函数和 ip_push_pending_frames()函数
进行修该以实现 PRIP 冗余发送的功能。主要基于以下考虑:
(1)UDP 协 议 数 据 包 的 路 由 是 在 udp_sendmsg() 函 数 里 完 成 的 。 在 标 准 Linux
内 核 中 ,udp_sendmsg()函数如果 UDP 套接字没有调用 connect()系统调用的话,那么需要数据包进
行路由,如果路由失败,在放弃数据包的发送。
本设计修改 udp_sendmsg()函数:在为数据包路由失败的情况下,将以从包 IP 目的地址为目的地址
再次进行路由。最后记录在本函数里面,是为哪个包成功进行了路由。
(2)ip_push_pending_frames()函数中涉及到 ip 数据包的 IP 选项的创建,因而,根据“就近修改原
则”,将主从包的 PRIP 选项的创建放在这里比较合适。最终,将在本函数里,实现从包的生成、PRIP 协
议 IP 选项的构建和主从包的发送。
udp_sendmsg()函数位于传输层,ip_push_pending_frames()函数位于 IP 网络层的顶部。 所以
UDP 协议 PRIP 协议冗余发送处理在传输层和 IP 网络层里共同实现。
udp_sendmsg()函数位于 Linux4.9.130/net/ipv4/udp.c 文件里。修改后的函数源码如下:

```
int udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
{
................
}
```



udp_sendmsg()函数在对主包进行路由失败的情况下,会继续进行从包进行路由,最后将记录是
为包还是从包成功进行了路由。 以供 ip_push_pending_frames()函数查看。在
ip_push_pending_frames()函数里面,查看是为主包还是为从包成功过进行了路由。如果之前对主包成
功进行了路由,那么在 ip_push_pending_frames() 函 数 里 对 从 包 进 行 路 由 ; 如 果 之 前 对
从 包 成 功 进 行 了 路 由 , 那 么 在 ip_push_pending_frames()函数里对主包进行路由;最后,完
成从包的生成、主从包 PRIP 选项的创建和主从包的发送工作。



## 3 PRIP 冗余接收功能实现

PRIP 冗余接收功能需求为:
正常情况下,由于 PRIP 采用数据传输冗余特性,在 PRIP 数据包接收时,会收到两份互为冗余的数
据包。为了保证数据的实时性,本解决方案采用:对于接收到的这两份数据包,首先到达的数据包进行接
收,后续到达的数据包予以丢弃处理,并在此过程中更新相关的统计信息。
这一需求要求操作系统能够识别数据包携带的 PRIP 相关 IP 选项,并予以解析,提取出数据包的
PRIP 序列号和主从标识,并采用特定的算法对重复的数据包丢弃处理,来保证数据通信的效率和实时性。
由上述可知,接收处理算法主要围绕者 IP 选项的解析和处理来实现的,因此将 PRIPS 数据接收冗余包
丢弃处理的功能实现放在协议栈的 L3 层较为合适。采用独立的模块不能完全实现所需的功能,故我们
的方案采用在协议栈 L3 层数据包接收路径的合适站点直接嵌入代码来实现。
如下图 A,正常的协议栈 L3 层数据接收流程如下:
(1) ip_rcv()函数。ip_rcv()函数所作的工作有:判断 IP 协议头长度是否正确,查看协议头协议信
息是否正确,查看 IP 协议头校验和是否正确,以上若有一项不满足将数据包丢弃;执行网络过滤子系统
钩子点 NF_INET_PRE_ROUTING 处所挂载的回调函数,之后调用 ip_rcv_finish()函数。(2) ip_rcv_finish()函数。 ip_rcv_finsih()函数所作的工作有:查看数据包是否有路由信息,若
没有,则通过路由子系统进行路由信息查找;如果有 IP 选项的话,解析并处理 IP 选项;最后调用路由子
系统的输入函数,即,dst->input()函数;
(3) ip_local_deliver()函数。dst->input()虚函数,当输入数据包不属于本机时候, dst->input()函数被初始化为 ip_forword()函数,当输入数据包属于本机时,dst->input()被初始化为
ip_local_deliver()函数。 这里介绍 ip_local_deliver()函数。 该函数所作的工作主要三个:首先看
接收到的数据包是否是分片数据包,如果是的话,需要对 IP 分片数据包进行重组处理;其次,依次 执 行
网 络 过 滤 子 系 统 NF_INET_LOCAL_IN 钩 子 点 处 的 注 册 的 所 有 回 调 函 数 ; 最 后 ,
调 用ip_local_deliver_finish()函数。
(4) ip_local_deliver_finish()函数。ip_local_deliver()函数功能有两个:将数据包去掉三层协
议头,使其缓存区指针指向四层协议头开始的位置;根据数据包的协议栈四层协议类型将调用相应的四层
协议的入口函数将数据包传送给协议栈四层。
如下图 B,根据功能需要,本解决方案选择在协议栈 L3 层顶部 ip_local_deliver()函数里面实现
PRIP 协议的冗余接收功能。具体位置在 ip_local_deliver()函数的数据包分片组装之后。在发送
PRIP 数据包时候,我们选择在数据包分片之前,进行 PRIP 的发送处理;在接收 PRIP 数据包的时候,我
们选择在数据包的分片之后,进行 PRIP 包的接收处理。



![](图片/prip相关linux内核协议栈分析和调测技术/4.png)             

  

PRIP 接收处理流程如下图所示。简述如下:
(1) 由于在此之前,IP 选项已经解析完毕存入数据包缓存结构体里面,所以在数据包进入 PRIP 接收
处理模块后,可直接从结构体 Ip_options 里获取数据包所携带的 PRIP 序列号和主从包标志。
(2) 获取 PRIP 序列号和主从包的标志之后,判断该数据包是主包还是从包。(3) 如果数据包是从包,需要将从包的目的 IP 替换为本地 PRIP 设备的主网卡接口 IP。
(4) 之后将数据包交给重复包丢弃算法进行处理。 如果该序列号的数据包已经收到,进行丢弃处理;
如果该序列号的数据包是第一次到达,则予以接收。
(5) 数据包相关统计数据更新。
(6) 进入报警处理。报警处理算法会根据数据包的统计数据对主从链路运行状态进行检查,之后决
定是否发出告警信息。
(7) 最后数据包离开 PRIP 数据接收处理模块。
将 PRIP 协议冗余接收功能实现放在 ip_local_deliver()函数中,IP 分片包组装之后。主要基于
两点考虑:(1)IP 选项包括 PRIP 协议 IP 选项已经在之前的 ip_rcv_finish()函数里面解析完毕;(2)
在 IP 分片组装之后实现冗余接收可以排除主从分片包的干扰,简化设计。例如若在 IP 分片包组装之
前进行冗余接收,同一个 IP 对儿可能收到分别属于互为冗余的主从包的多个 IP 分 片 包 ,这些包具
有相同的 PRIP 序列号,这将给冗余接收算法提出更高要求,增加设计的复杂度。

![](图片/prip相关linux内核协议栈分析和调测技术/5.png) 

ip_local_deliver()函数位于内核路径 Linux4.9.130/include/net/ip_input.c 下。本方案选择在该
函似内部直接嵌入冗余接收代码以实现 PRIP 协议冗余接收功能。 修改后的 ip_local_deliver()函数
代码如下所示,其中黑体部分为增加的 PRIP 冗余接收功能实现代码:

```
int ip_local_deliver(struct sk_buff *skb)
{
/*
* Reassemble IP fragments.
*/#ifdef CONFIG_PRIP

}
```



}
本设计在 ip_local_deliver()函数里面实现了 PRIP 数据冗余接收的完整框架,具体包括:
(1)PRIP 选项的获取解析。(内部实现)
(2)从包目的 IP 替换。(内部实现)
(3)冗余接收算法。(通过调用 prip_check())
(4)链路故障报警算法。(通过调用 prip_check())



### 3.1 PRIP 协议 IP 选项处理

在 linux 中 IP 选项的结构体为 struct ip_options,为了能够处理 PRIP 协议 IP 选项,需要在
其里面添加 PRIP 选项的相关的成员域,其定义位于 Linux4.9.130/include/net/inet_sock.h 文件中,
下面黑体部分为添加的 PRIP 协议 IP 选项相关的成员,具体定义如下:

```
struct ip_options {
__be32
faddr;
__be32
nexthop;
unsigned char optlen;
unsigned char srr;
unsigned char rr;
unsigned char ts;
unsigned char is_strictroute:1,
srr_is_hit:1,
is_changed:1,
rr_needaddr:1,
ts_needtime:1,
ts_needaddr:1;
unsigned char router_alert;
unsigned char cipso;
#ifdef CONFIG_PRIP
unsigned char prip;
#endif
unsigned char
unsigned char
__pad2;
__data[0];
};
```

ip_options 结构体中存放了需要发送、前送或者接收后解析出来的 IP 选项,它描述的不是某一个
类型的 IP 选项,而是一个数据包携带的所有 IP 选项的集合,下面介绍个数据域的基本含义:
faddr:只针对对外发送数据,并设置了源路由选项时才有意义,faddr 存放源路由列表中的第一个
IP 地址。
optlen:该数据域表示设置了的 IP 选项的总长度,最大不超过 40 个字节。
srr:指的是源路由选项存放在 IP 协议头中的偏移量。rr:如果 rr 值非零,IP 选项中设置了记录数据经过路由的 IP 地址选项,rr 的值代表路由器应在
IP 协议头何处记录路由选项的偏移量。
ts:如果 Ts 为非零值,表示 IP 选项里设置时间戳选项,而 ts 代表了时间戳选项记录在 IP 协议
头中的位置的偏移量。
is_strictroute:该值为 TRUE 时,表示 IP 选项中设置的源路由选现是严格源路由选项。
srr_is_hit:标志位数据域, 该位为 TRUE 时,说明数据包设置了源路由选项。在为发送数据包做路
由决策时,通过 skb->dst 或路由表获取下一跳与源路由表中下一跳一致成为 IP 地址命中。
is_change: 标志位数据域,若 IP 协议头发生变化,则设置该位。IP 协议头是否发生变化决定了是
否需要重新计算检验和。
rr_needaddr: 标志位数据域。当 IP 选项设置了记录路由选项时,如果 rr_needaddr 的值为 1 时,
表明协议头还有空间记录其他路由信息,这时当前站点应该就发送数据包的网络接口 IP 地址复制到协
议头中 rr 指定的偏移量处。
ts_needtime: 标志位数据域。表示时间戳选项到达站点的时间。
router_alert:如果 IP 选项中设置了路由报警选项时,该数据域表示路由报警选项在 IP 协议头存
放位置的偏移量。
__pad0:此数据域是为了是 IP 选项处于四字节对齐而加在最后的填充数据的个数。
__data[0]:该数据域指向存放要加入数据包协议头的 IP 选项的地址。
最后,被条件编译包含的是 prip 数据域,当编译内核选择 CONFIG_PRIP 选项时候,该数据域名将生
效。 prip 数据域的为 0 时,表明该数据包对应的应用程序没有使能 PRIP 功能,为普通的 IP 数据包;
当 prip 数据域为非 0 时,表明该数据包为 PRIP 数据包,其值是 PRIP 协议 IP 选项在 IP 协议头中的
所处位置的偏移量。
在 IP 网络层发送 IP 数据包时,如果发送的是 PRIP 数据包,则需要为该数据包构建 PRIP 协议 IP
选 项 , Linux 构 建 IP 选 项 的 函 数 为 ip_options_build() 函 数 , 位 于 内 核 代 码
Linux4.9.130/net/ipv4/ip_options.c 路径下。 我们需要在该函数内部嵌入构建 PRIP 协议 IP 选项
的代码,修改后的 ip_options_build()函数如下

```:
void ip_options_build(struct sk_buff *skb, struct ip_options *opt,
__be32 daddr, struct rtable *rt, int is_frag)
{

}
```

如果是属于 PRIP 数据包的话 , 那么构建 PRIP 协议 IP 选项。调用 prip_priv_find() 函数获取该
IP 对儿的私有结构体 struct prip_priv, 该结构体包了本 IP 对儿 PRIP 通信所需的全部信息。
prip_priv_find() 函数通
过 数 据 包 的 源 、 目 的 IP 计 算 哈 希 值 在 全 局 哈 希 表 prip_hash[] 里 找 到 本 IP 对 儿 的
struct prip_priv 结构体。
调用 get_pripid() 函数获取 PRIP 序列号 pripid 和发送时间戳 snd_start 。 get_pripid() 函数
除了从 struct prip_priv 直接获取 PRIP 序列号 pripid 和发送时间戳 snd_start 外 , 还会负责
PRIP 序列号 pripid 和发送时间戳 snd_start 更新和维护。
最后将获取 PRIP 序列号 pripid 和发送时间戳 snd_start 按照 PRIP 协议 IP 选项格式复制到 ip
协议头 PRIP 选项的正确位置。



### 3.2 多 PRIP 主机通信实现

在更常见的多 PRIP 主机进行通信时候,一个比较容易忽视的问题就是序列号的管理问题。PRIP 序
列号是 PRIP 进行冗余通信的重要基础,PRIP 主机主要依据数据包携带的序列号来实现冗余包的丢弃。
在一个 PRIP 主机组成的局域网内,每个 PRIP 主机在发送数据时候,都会为发送数据包添加新的 PRIP
序列号,因此在此局域网内就会存在多个 PRIP 序列号。为了避免多序列号的混乱而引起的数据接收错
误,如何组织管理这些不同的序列号将显得尤为重要。
每两台进行 PRIP 通信的主机被成为一个 PRIP 协议 IP 对。本解决方案为每一个 IP 对维护了一
个 PRIP 通信私有数据结构体 struct prip_priv 。

```
struct prip_priv{

};
```



该私有数据结构体包含了本 IP 对进行 PRIP 通信所需的全部信息,包括发送序列号、接收状态缓
存位图、对端主网络 IP、本机主网络 IP、主网络运行状态、 从网络运行状态、主网络发包个数、主
网络收包个数、 从网络发包个数、 从网络收包个数以及需要访问本私有数据结构的所需要获取的一些
锁。其中最重要的是本 IP 对发送序列号和本 IP 对接收状态缓存位图。这样的话,属于每个 IP 对的
两台主机进行 PRIP 通信时候,使用的是自己独有的 PRIP 序列号,可保证多 PRIP 主机通信时候的多个
序列号不会发生混乱。
结构体数据成员 refcnt 和 timer 分别是该结构体的引用计数和老化定时器。timer 定时时间在
结构体创建初始化时被初始化为 60s。每次使用到本结构体时会将引用计数 refcnt 加一,并将老化定
时器的定时时间重新初始化为 60s。定时器定时回调函数会查看该结构体的 refcnt 是否为 0,如果是
的话,则会释放接收状态位图 link 指向的内存和本结构体 struct prip_priv 的内存空间。在内核中
维护了一张全局的哈希表 prip_hash[PRIP_HASHSZ] ,哈希表容量为 64,每个 IP 对所属的 prip_priv
都会以其本机主网络 IP 和对端主网络 IP 计算出来的哈希值为索引放入这个哈希表里面。

![](图片/prip相关linux内核协议栈分析和调测技术/6.png) 

struct prip_priv 结构体的查找实现函数为 prip_find() 。 位于 Linux4.9.130/net/prip
/prip.c 文件里 , 该文件是 PRIP 项目添加到内核的新文件。 prip_find() 函数代码实现如下 :

```
struct prip_priv * prip_priv_find(__u32 localip, __u32 peerip){
int hash;
struct prip_priv * q;

}
```

注释 1:根据目的 IP 和源 IP 生成哈希值。
注释 2:每次访问 struct prip_priv 结构体都会将其老化到期时间顺延至本时刻将来 60 秒那刻。
注释 3:如果在哈希表里没有找到符合条件的 struct prip_priv 结构体,有可能是第一次接收或发
送数据,或者是已经被定时器删除,那么为本 IP 对儿重新申请一个 struct prip_priv 结构体,初始化
之后,插入全局哈希表,并返回新创建的 struct prip_priv 结构体指针。在 IP 网络层,对于 PRIP 协
议数据包,在发送和接收时候均会调用该函数。在发送数据时,会根据数据包的源、目的 IP 在全局哈希
表 prip_hash[PRIP_HASHSZ]里 查找到该数据包的 structprip_priv ,进而获得本 IP 对的 PRIP 发送
序列号;在接收数据时,根据接收到的数据包的源、目的 IP 在全局哈希表 prip_hash[PRIP_HASHSZ] 里
查找该数据包的 struct prip_priv ,进而获得 PRIP 接收状态位图表地址,最后采用重复包丢弃算法实
现数据包的唯一接收。

### 3.3 重复包丢弃算法

重复包丢弃算法是 PRIP 冗余接收模块的核心。重复包丢弃算法要实现的主要功能是:对于一个数
据包,根据其携带的 PRIP 序列号和发送时间戳去查询 PRIP 接收状态缓存位图,看在本轮 PRIP 序列号
轮转中,该序列号的数据包是否是第一次到达,如果是,则予以接收,并更新该序列号在缓存表中的接收状
态;否则,是重复包,予以丢弃。需要指出的是,当本主机与多个其他主机进行 PRIP 通信时,须在本机上
为每一个通信的远端主机维护一个 PRIP 接收状态缓存位图,以保证序列号的顺承一致。最终在本机上
维护了一张全局哈希表来组织这些 PRIP 接收状态缓存位图,以本机 PRIP 主 IP、远端 PRIP 主 IP 生
成哈希键值进行散列,以保证查表效率。



重复包丢弃算法主要涉及三个重要的数据结构:PRIP 协议 IP 选项、PRIP 接收状态缓存位图和全
局散列表。 位图散列表的容量为 64,每个桶存放的是链表头,每个链表会存放对应的 PRIP 接收状态缓
存位图地址和一些辅助数据结构。PRIP 接收状态缓存表如下图所示。

![](图片/prip相关linux内核协议栈分析和调测技术/7.png) 

PRIP 接收状态缓存表是由 65535 个比特位置组成,共占 8192 个字节的位图表。该表有两个辅助
数据 JIFFIES_L 和 JIFFIES_H,JIFFIES_L 被称为前半轮发送时间戳,指的是与本机 PRIP 通信的远端
主机发送本轮 PRIP 序列号为 1 的主包时的系统 jiffies,在本轮序列号轮转的前半轮中,远端主机将
一直使用该时间戳来生成数据包的 PRIP 协议 IP 选项,发送到本机。同样 ,JIFFIES_H 称为后半轮发
送时间戳,指的是与本机 PRIP 通信的远端主机发送序列号为 32768 的数据包时的系统 jiffies,在发
送序列号 32768 到 65535 的数据包时,均将该 jiffies 添加到数据包的 PRIP 协议 IP 选项,发送到本
机。简言之,在发送 PRIP 数据包时,序列号 1~32767 的数据包携带的时间戳为 JIFFIES_L,它的值为发
送本轮序列号为 1 的数据包时的本地系统 jiffies。序列号 32768~65535 的数据包携带的时间戳为
JIFFIES_H,值等于发送本轮序列号为 32769 的主包时的本地系统 jiffies。
重复包丢弃算法在函数 prip_check()函数里面实现,该函数被 PRIP 数据接收函数
ip_local_deliver()调用。prip_check()位于 Linux4.9.130/net/prip/prip.c 文件里面。函数代码如
下:

```
int prip_check(u16 seq, int isdup, struct prip_priv *priv, unsigned long start)
{

}
```



重复包丢弃算法流程图如下图所示。在进入丢弃算法之前,PRIP 协议 IP 选项已经解析完毕,可以
直接获取数据包的发送时间戳和序列号。序列号属于前半轮和属于后半轮的处理情况呈镜像对称,为了
简便起见,这里只叙述序列号属于前半轮时候的情况。如下:
(1)获取数据包携带的发送时间戳;
(2)获取数据包的 PRIP 序列号;
(3)判断数据包序列号属于前半轮还是后半轮。我们只分析序列号属于前半轮的情况;
(4)将本时间戳与本地缓存的 JIFFIES_L 比较;
(5)对于第(4)步骤的比较结果,可分三种情况,
当时间戳小于 JIFFIES_L 时:
a.数据包丢弃,返回 1;
当时间戳大于 JIFFIES_L 时:
a.用提取的时间戳更新 JIFFIES_L;
b.将接收状态接收位图前半部所有位清零;
c.接收数据包,返回 0。
当时间戳 JIFFIES_L 时:
a.根据 PRIP 序列号查询接收状态位图的相应位;
b.判断查询到的位图位,分两种情况:
1).若为 0,将之置 1,接收数据包,返回 0;
2).若为 1,丢弃数据包,返回 1。

![](图片/prip相关linux内核协议栈分析和调测技术/8.png) 